# JavaScript

> 브라우저 화면을 '동적'으로 만들기 위한, 브라우저를 조작할 수 있는 유일한 언어

- **DOM** : HTML, XML과 같은 **문서**를 다루기 위한 프로그래밍 인터페이스
  - 파싱 : 브라우저가 문자열을 해석하여 DOM Tree로 만드는 과정

- **BOM **: 자바스크립트가 **브라우저**와 소통하기 위한 모델



### 변수와 식별자



#### 식별자 

- 변수를 구분할 수 있는 변수명. 문자, 달러($), 밑줄(_)로 시작

- 대소문자 구분하며, 클래스명 외에는 모두 소문자로 시작함
- 예약어(for, if, function 등) 사용 불가능



#### 식별자 작성 스타일

- 카멜케이스(camelCase) : **변수, 객체, 함수**에 사용 (ex. articleCreate())
- 파스칼 케이스(PascalCase) : **클래스, 생성자**에 사용 (ex. class ArticleSerialzer)
- 대문자 스네이크 케이스(SNAKE_CASE) : **상수** (변경될 가능성이 없는 값)에 사용



#### 변수 선언 키워드 - let, const

> 2016년도 let, const 도입 후(es6)에는 var는 잘 사용하지 않음

1. **let **

   - 재할당 할 예정인 변수 선언 시 사용
   - 변수 재선언 불가능
   - 블록 스코프 : {}
     - if, for, 함수 등의 **중괄호 내부**를 가리킴. 블록 스코프를 가지는 변수는 블록 바깥에서 접근 불가능

   ```javascript
   let foo       // 선언
   foo = 11      // 할당
   let bar = 0   // 선언+할당
   let bar = 2   // 재선언 불가능 SyntaxError
   ```

2. **const**

   - 재할당 할 예정이 없는 변수 선언 시 사용 ( = 을 못쓴다)
   - 변수 재선언 불가능
   - 블록 스코프 : {}

   ```javascript
   const number = 10 // 선언 및 초기값 할당
   number = 10       // 재할당 불가능 -> Type Error
   const number = 20 // 재선언 불가능 SyntaxError
   ```

3. **var**
   
   - 재선언 및 재할당 모두 가능하지만, 호이스팅 되는 특성으로 사용하지 않는 것을 권장함
   - 호이스팅
     - 변수 선언 이전에 참조할 수 있는 현상. 변수 선언 이전의 위치에서 접근 시 undefined를 반환 (에러가 나지 않음)
   - 함수 스코프 : 함수 내에서 선언된 변수는 함수 내에서만 유효하다.



### 데이터 타입



#### 원시타입(Primitive type)

> Number, String, Boolean, null, undefined
>
> - 객체가 아닌 기본 타입
> - 변수에 해당 타입의 값이 담김
> - 다른 변수에 복사할 때 실제 값이 복사 됨

- **NaN** : 계산 불가능한 경우 반환되는 값 (에러 반환 x)
  - type(NaN) : number
- **String** : 텍스트 데이터를 나타내는 타입
  - 작은 따옴표, 큰 따옴표 모두 사용 가능
  - 템플릿 리터럴 : 백틱, ${expression} 형태로 표현 식 삽입 가능
- **undefined** : 변수의 값이 없음을 나타내는 데이터 타입
  - 변수 선언 이후 직접 값을 할당하지 않으면, **자동**으로 undefined가 할당됨

- **null** : 변수의 값이 없음을 **의도적**으로 표현할 때

  - type(null) : object

- **Boolean** : 논리적 참 또는 거짓(true or false)을 나타내는 타입

  - 조건문 또는 반복문에서 유용하게 사용

  - 자동 형변환

    ![image-20220425145134161](0425.assets/image-20220425145134161.png)

#### 참조타입(Reference type)

> Array, Function

- 객체 타입의 자료형
- 변수에 해당 객체의 참조 값이 담김
- 다른 변수에 복사할 때 참조 값이 복사됨



### 연산자



#### 할당 연산자

- ++ : 피연산자의 값을 1 증가시키는 연산자, -- : 피연산자의 값을 1 감소시키는 연산자

  > 다만, 더 분명한 표현인 +=, -= 로 적을 것을 권장함



#### 비교 연산자

- 동등 비교 연산자 (==) : 예상치 못한 결과가 발생할 수 있으므로 특별한 경우를 제외하고는 사용하지 않음

  ```javascript
  1 == '1'
  true
  ```

- **일치 비교 연산자 (===)** : 두 피연산자가 같은 값으로 평가되는지 비교 후 bool 값을 반환
  - **엄격한 비교(타입(자료형)과 값이 모두 같은 지 확인)**가 이루어짐



#### 논리 연산자

- and : &&
- or : ||
- 

- 단축 평가 지원



#### 삼항 연산자

> 콜론(:)으로 구분

- (표현식 ? x : y ) 
  - 표현식 맞아? yes -> x, no -> y



### 조건문



#### if 

> 조건은 소괄호 안에 작성. 실행할 코드는 중괄호 안에 작성

```javascript
const nation = 'Korea'

if (nation === 'Korea') {          // (이 부분에 조건이 들어옴)
    console.log('안녕하세요!')       // {여기에 실행할 코드}
} else if (nation === 'France') {
    console.log('Bonjour!')
} else {
    console.log('Hello!')
}
```



#### switch

> 표현식의 결과값을 이용한 조건문. 표현식의 결과값과  case문의 오른쪽 값을 비교
>
> 최근 python에도 비슷한 match라는 문법이 생김

```javascript
const nation = 'Korea'

swith(nation) {
    case 'Korea': {
        console.log('안녕하세요!')
        break                      // break가 있어야 멈춤. 아니면 나머지 구문 다 실행
    }
    case 'France': {
        console.log('Bonjour!')
        break
    }
    default: {
        console.log('Hello!')
    }
}
```



### 반복문



#### while

#### for

```javascript
for (initialization; condition; expression) {
    // do something
}

for (let i=0; i<10; i++) {   // 최초 i는 0, i가 10보다 작은지, i를 1씩 늘려라
    console.log(i)           // 0 1 2 3 4 5 6 7 8 9
} 
```

- initialization : 최초 반복문 진입 시 1회만 실행되는 부분
- condition : 매 반복 시행 전 평가되는 부분
- expression : 매 반복 시행 이후 평가되는 부분



#### for ... in

```javascript
for (variable in object) {
    // do something
}
```

- 객체(object,딕셔너리)의 속성(key)들을 순회할 때 사용
- 배열 순회는 권장하지 않음
  - 배열로 돌리면 인덱스가 출력됨



#### for ... of

```javascript
for (variable of iterables) {
    // do something
}
```

- 반복가능한(iterable) 객체를 순회 하며 값(value)을 꺼낼 때 사용

![image-20220425155454840](0425.assets/image-20220425155454840.png)